name: Build and Release

on:
  push:
    branches: [ main ]
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.0.0)'
        required: false
        type: string

# Give the workflow write permissions to create releases
permissions:
  contents: write
  packages: write

jobs:
  create-release:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get-version.outputs.version }}
      upload_url: ${{ steps.create-release.outputs.upload_url }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Get version
        id: get-version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ inputs.version }}" ]]; then
            VERSION="${{ inputs.version }}"
          elif [[ "$GITHUB_REF" == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/v}
          elif [[ "$GITHUB_REF" == refs/heads/release/* ]]; then
            BASE=${GITHUB_REF#refs/heads/release/}
            DOY=$(date +%j)
            HOUR=$(date +%H)
            # For MSI, prerelease must be numeric only
            VERSION="$BASE-${DOY}${HOUR}"
          else
            # CI-only builds for non-release branches
            DOY=$(date +%j)
            HOUR=$(date +%H)
            # For MSI, prerelease must be numeric only
            VERSION="0.0.0-${DOY}${HOUR}"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"
          
      - name: Generate Release Notes
        id: release-notes
        run: |
          # Get the last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          # Generate changelog
          if [ -n "$LAST_TAG" ]; then
            CHANGELOG=$(git log $LAST_TAG..HEAD --pretty=format:"- %s" --no-merges | head -20)
          else
            CHANGELOG=$(git log --pretty=format:"- %s" --no-merges | head -20)
          fi
          
          # Escape for GitHub Actions
          CHANGELOG="${CHANGELOG//'%'/'%25'}"
          CHANGELOG="${CHANGELOG//$'\n'/'%0A'}"
          CHANGELOG="${CHANGELOG//$'\r'/'%0D'}"
          
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
      - name: Create RC Release (release/* branch)
        id: create-release-rc
        if: startsWith(github.ref, 'refs/heads/release/')
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ steps.get-version.outputs.version }}
          name: JaTerm RC ${{ steps.get-version.outputs.version }}
          body: |
            ## JaTerm RC ${{ steps.get-version.outputs.version }}
            
            This is a release candidate intended for testing. It may contain changes that are not yet in the stable channel.
            
            ### ðŸ“¦ Installation
            
            #### Windows
            - **Installer**: Download `JaTerm_*.msi` for standard installation
            - **Portable**: Download `JaTerm_*-setup.exe` for NSIS installer
            
            #### macOS
            - **Intel**: Download `JaTerm_*_macos-intel.dmg`
            - **Apple Silicon**: Download `JaTerm_*_macos-apple-silicon.dmg`
            
            #### Linux
            - **AppImage**: Download `JaTerm_*.AppImage` (portable, no installation)
            - **Debian/Ubuntu**: Download `JaTerm_*.deb`
            
            ### ðŸ“ Recent Changes
            ${{ steps.release-notes.outputs.changelog }}
            
            ---
            [View all commits](https://github.com/${{ github.repository }}/compare/${{ steps.get-version.outputs.last_tag }}...v${{ steps.get-version.outputs.version }})
          draft: false
          prerelease: true
          generate_release_notes: false

      - name: Create Stable Release (tag)
        id: create-release-tag
        if: startsWith(github.ref, 'refs/tags/v')
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ steps.get-version.outputs.version }}
          name: JaTerm v${{ steps.get-version.outputs.version }}
          body: |
            ## JaTerm v${{ steps.get-version.outputs.version }}
            
            ### ðŸ“¦ Installation
            
            #### Windows
            - **Installer**: Download `JaTerm_*.msi` for standard installation
            - **Portable**: Download `JaTerm_*-setup.exe` for NSIS installer
            
            #### macOS
            - **Intel**: Download `JaTerm_*_macos-intel.dmg`
            - **Apple Silicon**: Download `JaTerm_*_macos-apple-silicon.dmg`
            
            #### Linux
            - **AppImage**: Download `JaTerm_*.AppImage` (portable, no installation)
            - **Debian/Ubuntu**: Download `JaTerm_*.deb`
            
            ### ðŸ“ Recent Changes
            ${{ steps.release-notes.outputs.changelog }}
            
            ---
            [View all commits](https://github.com/${{ github.repository }}/compare/${{ steps.release-notes.outputs.last_tag }}...v${{ steps.get-version.outputs.version }})
          draft: false
          prerelease: false
          generate_release_notes: false

  build:
    needs: create-release
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            name: windows
            ext: .msi
            
          - os: macos-latest
            target: x86_64-apple-darwin
            name: macos-intel
            ext: .dmg
            
          - os: macos-latest
            target: aarch64-apple-darwin
            name: macos-apple-silicon
            ext: .dmg
            
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            name: linux
            ext: .AppImage

    runs-on: ${{ matrix.os }}
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8
          
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}
          
      - name: Install cargo-zigbuild (for cross-compilation)
        if: matrix.os == 'macos-latest' || matrix.os == 'ubuntu-latest'
        run: |
          cargo install cargo-zigbuild
          
      - name: Install Linux dependencies
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            librsvg2-dev \
            patchelf \
            libgtk-3-dev \
            libssl-dev
          # Try to install appindicator (use ayatana if available, fallback to older version)
          sudo apt-get install -y libayatana-appindicator3-dev || sudo apt-get install -y libappindicator3-dev
            
      - name: Import macOS certificate
        if: matrix.os == 'macos-latest'
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
        run: |
          # Create temporary keychain
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          
          echo "Creating keychain at: $KEYCHAIN_PATH"
          echo "Keychain password length: ${#KEYCHAIN_PASSWORD}"
          
          # Create keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH || { echo "Failed to create keychain"; exit 1; }
          echo "Keychain created successfully"
          
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH || { echo "Failed to set keychain settings"; exit 1; }
          echo "Keychain settings configured"
          
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH || { echo "Failed to unlock keychain"; exit 1; }
          echo "Keychain unlocked successfully"
          
          # Verify keychain is accessible
          security show-keychain-info $KEYCHAIN_PATH || { echo "Cannot access keychain info"; exit 1; }
          echo "Keychain is accessible"
          
          # Import certificate
          echo "$APPLE_CERTIFICATE" | base64 --decode > certificate.p12
          
          # Verify certificate MD5 (should match our local certificate)
          CERT_MD5=$(cat certificate.p12 | base64 | md5)
          echo "Certificate MD5 after decode and re-encode: $CERT_MD5"
          echo "Expected base64 MD5: 6d4bfdbcc85360bfa26ec5c55a8f9378"
          
          # Also check the direct MD5 of the p12 file
          P12_MD5=$(md5 -q certificate.p12)
          echo "Direct P12 file MD5: $P12_MD5"
          echo "Expected P12 MD5: 2f9240803fe8dad5264f1e8854b6b519"
          
          # Debug password (hash it to avoid exposing in logs)
          PASSWORD_MD5=$(echo -n "$APPLE_CERTIFICATE_PASSWORD" | md5)
          echo "Password MD5 hash: $PASSWORD_MD5"
          echo "Expected password MD5: 431e6a25010e3b921b58d172e7e6d704"
          echo "Password length: ${#APPLE_CERTIFICATE_PASSWORD}"
          echo "Expected length: 25"
          
          # Test certificate with openssl before importing
          echo "Testing certificate with openssl..."
          openssl pkcs12 -in certificate.p12 -passin pass:"$APPLE_CERTIFICATE_PASSWORD" -noout -info 2>&1 | head -5 || echo "OpenSSL verification failed"
          
          # Try different methods to import the certificate
          echo "Method 1: Standard import with -P flag"
          security import certificate.p12 -k $KEYCHAIN_PATH -P "$APPLE_CERTIFICATE_PASSWORD" -T /usr/bin/codesign || echo "Method 1 failed"
          
          echo "Method 2: Import with -f pkcs12 format specified"
          security import certificate.p12 -k $KEYCHAIN_PATH -P "$APPLE_CERTIFICATE_PASSWORD" -f pkcs12 -T /usr/bin/codesign || echo "Method 2 failed"
          
          echo "Method 3: Import with passphrase via stdin"
          echo "$APPLE_CERTIFICATE_PASSWORD" | security import certificate.p12 -k $KEYCHAIN_PATH -P - -T /usr/bin/codesign || echo "Method 3 failed"
          
          echo "Method 4: Import without -T flag"
          security import certificate.p12 -k $KEYCHAIN_PATH -P "$APPLE_CERTIFICATE_PASSWORD" || true
          
          # List keychains and add to search list
          echo "Adding keychain to search list:"
          security list-keychain -d user -s $KEYCHAIN_PATH login.keychain-db
          echo "Current keychain list:"
          security list-keychain -d user
          
          # Check what was imported
          echo "Checking imported identities:"
          security find-identity -v -p codesigning $KEYCHAIN_PATH || echo "No identities found"
          
          # Allow codesign to access keychain
          echo "Setting key partition list..."
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH || echo "Failed to set partition list"
          
          # Check again after partition list
          echo "Checking identities after partition list:"
          security find-identity -v -p codesigning $KEYCHAIN_PATH || echo "Still no identities found"
          
          # Find the actual signing identity string
          echo "Finding actual signing identity..."
          ACTUAL_IDENTITY=$(security find-identity -v -p codesigning $KEYCHAIN_PATH | grep "JaTerm" | head -1 | sed 's/.*"\(.*\)".*/\1/' || echo "")
          
          if [ -z "$ACTUAL_IDENTITY" ]; then
            echo "Warning: Could not find JaTerm identity, using provided identity"
            ACTUAL_IDENTITY="$APPLE_SIGNING_IDENTITY"
          else
            echo "Found actual identity: $ACTUAL_IDENTITY"
          fi
          
          # Also check default keychain
          echo "Checking default keychain for identities:"
          security find-identity -v -p codesigning || echo "No identities in default keychain"
          
          # Export for Tauri - use the actual found identity
          echo "APPLE_SIGNING_IDENTITY=$ACTUAL_IDENTITY" >> $GITHUB_ENV
        
      - name: Update version (Unix)
        if: matrix.os != 'windows-latest'
        env:
          TAURI_UPDATER_PUBKEY: ${{ vars.TAURI_UPDATER_PUBKEY }}
        run: |
          VERSION="${{ needs.create-release.outputs.version }}"
          echo "Setting version to: $VERSION"
          
          # Update package.json
          sed -i.bak "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" package.json || true
          sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" package.json || true
          
          # Update src-tauri/Cargo.toml
          sed -i.bak "s/^version = .*/version = \"$VERSION\"/" src-tauri/Cargo.toml || true
          sed -i "s/^version = .*/version = \"$VERSION\"/" src-tauri/Cargo.toml || true
          
          # Update tauri.conf.json version
          sed -i.bak "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" src-tauri/tauri.conf.json || true
          sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" src-tauri/tauri.conf.json || true
          
          # Inject the public key if available
          if [ -n "$TAURI_UPDATER_PUBKEY" ]; then
            sed -i.bak "s/PUBKEY_PLACEHOLDER_REPLACE_IN_CI/$TAURI_UPDATER_PUBKEY/" src-tauri/tauri.conf.json || true
            sed -i "s/PUBKEY_PLACEHOLDER_REPLACE_IN_CI/$TAURI_UPDATER_PUBKEY/" src-tauri/tauri.conf.json || true
          fi
          
      - name: Update version (Windows)
        if: matrix.os == 'windows-latest'
        env:
          TAURI_UPDATER_PUBKEY: ${{ vars.TAURI_UPDATER_PUBKEY }}
        shell: pwsh
        run: |
          $VERSION = "${{ needs.create-release.outputs.version }}"
          Write-Host "Setting version to: $VERSION"
          
          # Update package.json
          $packageJson = Get-Content package.json -Raw | ConvertFrom-Json
          $packageJson.version = $VERSION
          $packageJson | ConvertTo-Json -Depth 10 | Set-Content -Path package.json -NoNewline
          
          # Update src-tauri/Cargo.toml
          $cargoContent = Get-Content src-tauri/Cargo.toml -Raw
          $cargoContent = $cargoContent -replace '(?m)^version = ".*"', "version = `"$VERSION`""
          Set-Content -Path src-tauri/Cargo.toml -Value $cargoContent -NoNewline
          
          # Update tauri.conf.json
          $configPath = "src-tauri/tauri.conf.json"
          $json = Get-Content $configPath -Raw
          $config = $json | ConvertFrom-Json
          $config.version = $VERSION
          
          # Update pubkey if available (under plugins.updater.pubkey)
          if ($env:TAURI_UPDATER_PUBKEY) {
            if (-not $config.plugins) { $config | Add-Member -NotePropertyName plugins -NotePropertyValue @{} }
            if (-not $config.plugins.updater) { $config.plugins | Add-Member -NotePropertyName updater -NotePropertyValue @{} }
            $config.plugins.updater.pubkey = $env:TAURI_UPDATER_PUBKEY
          }
          
          $newJson = $config | ConvertTo-Json -Depth 10
          Set-Content -Path $configPath -Value $newJson -NoNewline
          
      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            src-tauri
            src-helper
            
      - name: Install frontend dependencies
        run: pnpm install
        
      - name: Build helper binary (native)
        run: |
          cd src-helper
          cargo build --release --target ${{ matrix.target }}
          
      - name: Build helper binary for Linux (musl)
        if: matrix.os == 'macos-latest' || matrix.os == 'ubuntu-latest'
        run: |
          cd src-helper
          cargo zigbuild --release --target x86_64-unknown-linux-musl || true
        continue-on-error: true
        
      - name: Prepare keychain for build (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          echo "Ensuring keychain is accessible for build..."
          # Re-export the keychain path if it was set
          if [ -n "$RUNNER_TEMP" ]; then
            export KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
            if [ -f "$KEYCHAIN_PATH" ]; then
              echo "Keychain exists at: $KEYCHAIN_PATH"
              # Make sure it's the default keychain for this session
              security default-keychain -s $KEYCHAIN_PATH
              echo "Set as default keychain"
              
              # Make sure it's in the search list
              security list-keychain -d user -s $KEYCHAIN_PATH login.keychain-db
              echo "Added to keychain search list"
              
              # Unlock it again to be sure
              KEYCHAIN_PASSWORD=$(openssl rand -base64 32)
              security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH 2>/dev/null || true
              
              # Verify the identity is still there
              echo "Verifying signing identity..."
              security find-identity -v -p codesigning $KEYCHAIN_PATH || echo "Warning: No identities found in custom keychain"
              security find-identity -v -p codesigning || echo "Warning: No identities found in default keychain"
              
              # Debug: show the actual signing identity being used
              echo "APPLE_SIGNING_IDENTITY environment variable: $APPLE_SIGNING_IDENTITY"
            fi
          fi
          
          # Remove test binary that shouldn't be signed in release builds
          echo "Removing test_keyring binary from release build..."
          rm -f src-tauri/src/bin/test_keyring.rs
      
      - name: Build Tauri app
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ env.APPLE_SIGNING_IDENTITY }}
        run: |
          pnpm tauri build --target ${{ matrix.target }}

      - name: Package helper (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path dist | Out-Null
          $helper = "src-helper/target/${{ matrix.target }}/release/jaterm-agent.exe"
          if (Test-Path $helper) { Copy-Item $helper -Destination "dist/jaterm-agent_windows_x64.exe" }
          
      - name: Fix macOS signatures and recreate DMG
        if: matrix.os == 'macos-latest'
        run: |
          # Fix the app bundle signature
          ./scripts/fix-macos-signature.sh --ci
          
          # Recreate the DMG with the properly signed app
          ./scripts/recreate-dmg.sh ${{ matrix.target }} ${{ needs.create-release.outputs.version }}
          
      - name: Prepare artifacts (Windows)
        if: matrix.os == 'windows-latest'
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
        shell: pwsh
        run: |
          # Windows creates MSI installer
          New-Item -ItemType Directory -Force -Path dist | Out-Null
          
          # Copy MSI installer
          $msiFiles = Get-ChildItem -Path "src-tauri\target\${{ matrix.target }}\release\bundle\msi\*.msi" -ErrorAction SilentlyContinue
          if ($msiFiles) {
            Copy-Item $msiFiles[0] -Destination "dist\JaTerm_${{ needs.create-release.outputs.version }}_x64.msi"
            
            # Copy MSI signature if available
            $sigFiles = Get-ChildItem -Path "src-tauri\target\${{ matrix.target }}\release\bundle\msi\*.msi.sig" -ErrorAction SilentlyContinue
            if ($sigFiles) {
              Copy-Item $sigFiles[0] -Destination "dist\JaTerm_${{ needs.create-release.outputs.version }}_x64.msi.sig"
            }
          }
          
          # Copy NSIS installer if available
          $exeFiles = Get-ChildItem -Path "src-tauri\target\${{ matrix.target }}\release\bundle\nsis\*.exe" -ErrorAction SilentlyContinue
          if ($exeFiles) {
            Copy-Item $exeFiles[0] -Destination "dist\JaTerm_${{ needs.create-release.outputs.version }}_x64-setup.exe"
          }
          
      - name: Prepare artifacts (macOS)
        if: matrix.os == 'macos-latest'
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
        run: |
          # macOS creates DMG and app.tar.gz for updater
          mkdir -p dist
          if [[ "${{ matrix.target }}" == "aarch64-apple-darwin" ]]; then
            # Copy DMG for manual installation
            cp src-tauri/target/${{ matrix.target }}/release/bundle/dmg/*.dmg dist/JaTerm_${{ needs.create-release.outputs.version }}_aarch64.dmg || true
            
            # Create app.tar.gz for auto-updater
            if [[ -d "src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app" ]]; then
              cd src-tauri/target/${{ matrix.target }}/release/bundle/macos/
              tar czf JaTerm.app.tar.gz JaTerm.app
              cd -
              cp src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app.tar.gz dist/JaTerm_${{ needs.create-release.outputs.version }}_aarch64.app.tar.gz
              
              # Generate signature for app.tar.gz if signing keys are available
              if [[ -n "$TAURI_SIGNING_PRIVATE_KEY" ]]; then
                echo "Generating signature for aarch64 app.tar.gz..."
                # Tauri should generate this automatically when built with signing keys
                if [[ -f "src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app.tar.gz.sig" ]]; then
                  cp src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app.tar.gz.sig dist/JaTerm_${{ needs.create-release.outputs.version }}_aarch64.app.tar.gz.sig
                fi
              fi
            fi
            
            # Copy helper (Apple Silicon)
            if [[ -f "src-helper/target/${{ matrix.target }}/release/jaterm-agent" ]]; then
              cp "src-helper/target/${{ matrix.target }}/release/jaterm-agent" "dist/jaterm-agent_macos_aarch64"
              chmod +x dist/jaterm-agent_macos_aarch64 || true
            fi
          else
            # Copy DMG for manual installation
            cp src-tauri/target/${{ matrix.target }}/release/bundle/dmg/*.dmg dist/JaTerm_${{ needs.create-release.outputs.version }}_x64.dmg || true
            
            # Create app.tar.gz for auto-updater
            if [[ -d "src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app" ]]; then
              cd src-tauri/target/${{ matrix.target }}/release/bundle/macos/
              tar czf JaTerm.app.tar.gz JaTerm.app
              cd -
              cp src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app.tar.gz dist/JaTerm_${{ needs.create-release.outputs.version }}_x64.app.tar.gz
              
              # Generate signature for app.tar.gz if signing keys are available
              if [[ -n "$TAURI_SIGNING_PRIVATE_KEY" ]]; then
                echo "Generating signature for x64 app.tar.gz..."
                # Tauri should generate this automatically when built with signing keys
                if [[ -f "src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app.tar.gz.sig" ]]; then
                  cp src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app.tar.gz.sig dist/JaTerm_${{ needs.create-release.outputs.version }}_x64.app.tar.gz.sig
                fi
              fi
            fi
            
            # Copy helper (Intel)
            if [[ -f "src-helper/target/${{ matrix.target }}/release/jaterm-agent" ]]; then
              cp "src-helper/target/${{ matrix.target }}/release/jaterm-agent" "dist/jaterm-agent_macos_x64"
              chmod +x dist/jaterm-agent_macos_x64 || true
            fi
          fi
          
      - name: Prepare artifacts (Linux)
        if: matrix.os == 'ubuntu-latest'
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
        run: |
          # Linux creates AppImage and deb
          mkdir -p dist
          
          # Copy AppImage and its signature for updater
          cp src-tauri/target/${{ matrix.target }}/release/bundle/appimage/*.AppImage dist/JaTerm_${{ needs.create-release.outputs.version }}_amd64.AppImage || true
          if [[ -f "src-tauri/target/${{ matrix.target }}/release/bundle/appimage/*.AppImage.sig" ]]; then
            cp src-tauri/target/${{ matrix.target }}/release/bundle/appimage/*.AppImage.sig dist/JaTerm_${{ needs.create-release.outputs.version }}_amd64.AppImage.sig || true
          fi
          
          # Copy deb package
          cp src-tauri/target/${{ matrix.target }}/release/bundle/deb/*.deb dist/JaTerm_${{ needs.create-release.outputs.version }}_amd64.deb || true
          
          # Make AppImage executable
          chmod +x dist/*.AppImage || true
          # Copy helper (gnu)
          if [[ -f "src-helper/target/${{ matrix.target }}/release/jaterm-agent" ]]; then
            cp "src-helper/target/${{ matrix.target }}/release/jaterm-agent" "dist/jaterm-agent_linux_x86_64"
            chmod +x dist/jaterm-agent_linux_x86_64 || true
          fi
          # Copy helper (musl) if built via zigbuild
          if [[ -f "src-helper/target/x86_64-unknown-linux-musl/release/jaterm-agent" ]]; then
            cp "src-helper/target/x86_64-unknown-linux-musl/release/jaterm-agent" "dist/jaterm-agent_linux_x86_64_musl"
            chmod +x dist/jaterm-agent_linux_x86_64_musl || true
          fi
          
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: jaterm-${{ matrix.name }}
          path: dist/
          
      - name: Upload Release Assets
        if: startsWith(github.ref, 'refs/tags/v') || startsWith(github.ref, 'refs/heads/release/')
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.create-release.outputs.version }}
          files: dist/*
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  generate-latest-json:
    needs: [create-release, build]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v') || startsWith(github.ref, 'refs/heads/release/')
    steps:
      - uses: actions/checkout@v4
      
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/
          
      - name: Prepare dist directory
        run: |
          mkdir -p dist
          # Copy all artifacts to dist, flattening the structure
          find artifacts -type f \( -name "*.msi" -o -name "*.AppImage" -o -name "*.dmg" -o -name "*.exe" -o -name "*.deb" -o -name "*.sig" -o -name "*.tar.gz" \) -exec cp {} dist/ \;
          ls -la dist/
          
      - name: Generate latest.json
        run: |
          VERSION="${{ needs.create-release.outputs.version }}"
          echo "Generating latest.json for version ${VERSION}"
          
          # Make script executable
          chmod +x scripts/generate-latest-json.sh
          
          # Generate latest.json
          ./scripts/generate-latest-json.sh "${VERSION}" "JaTerm ${VERSION} - Check the release page for details"
          
          # Verify it was created
          if [ -f dist/latest.json ]; then
            echo "latest.json generated successfully:"
            cat dist/latest.json
          else
            echo "Error: latest.json was not generated!"
            exit 1
          fi
          
      - name: Upload latest.json to Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.create-release.outputs.version }}
          files: dist/latest.json
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
