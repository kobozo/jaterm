name: Build and Release

on:
  push:
    branches: [ main ]
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.0.0)'
        required: false
        type: string

# Give the workflow write permissions to create releases
permissions:
  contents: write
  packages: write

jobs:
  create-release:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get-version.outputs.version }}
      upload_url: ${{ steps.create-release.outputs.upload_url }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Get version
        id: get-version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ inputs.version }}" ]]; then
            VERSION="${{ inputs.version }}"
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/v}
          else
            # Generate a valid semver version for automatic builds
            # Use 0.0.0-dev.YYYYMMDDHHMMSS format (no dots in prerelease)
            VERSION="0.0.0-dev$(date +%Y%m%d%H%M%S)"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"
          
      - name: Generate Release Notes
        id: release-notes
        run: |
          # Get the last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          # Generate changelog
          if [ -n "$LAST_TAG" ]; then
            CHANGELOG=$(git log $LAST_TAG..HEAD --pretty=format:"- %s" --no-merges | head -20)
          else
            CHANGELOG=$(git log --pretty=format:"- %s" --no-merges | head -20)
          fi
          
          # Escape for GitHub Actions
          CHANGELOG="${CHANGELOG//'%'/'%25'}"
          CHANGELOG="${CHANGELOG//$'\n'/'%0A'}"
          CHANGELOG="${CHANGELOG//$'\r'/'%0D'}"
          
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
      - name: Create Release
        id: create-release
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ steps.get-version.outputs.version }}
          name: JaTerm v${{ steps.get-version.outputs.version }}
          body: |
            ## JaTerm v${{ steps.get-version.outputs.version }}
            
            ### üì¶ Installation
            
            #### Windows
            - **Installer**: Download `JaTerm_*.msi` for standard installation
            - **Portable**: Download `JaTerm_*-setup.exe` for NSIS installer
            
            #### macOS
            - **Intel**: Download `JaTerm_*_macos-intel.dmg`
            - **Apple Silicon**: Download `JaTerm_*_macos-apple-silicon.dmg`
            
            #### Linux
            - **AppImage**: Download `JaTerm_*.AppImage` (portable, no installation)
            - **Debian/Ubuntu**: Download `JaTerm_*.deb`
            
            ### üöÄ Features
            - Terminal emulator with multiple panes
            - SSH client with key/password authentication
            - SFTP file transfer
            - Git integration
            - Port forwarding (local and remote)
            - Cross-platform (Windows, macOS, Linux)
            
            ### üìù Recent Changes
            ${{ steps.release-notes.outputs.changelog }}
            
            ### üîÑ Auto-Updates
            The app will automatically check for updates on startup. You can also manually check via the status bar.
            
            ---
            [View all commits](https://github.com/${{ github.repository }}/compare/${{ steps.get-version.outputs.last_tag }}...v${{ steps.get-version.outputs.version }})
          draft: true
          prerelease: false
          generate_release_notes: false

  build:
    needs: create-release
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            name: windows
            ext: .msi
            
          - os: macos-latest
            target: x86_64-apple-darwin
            name: macos-intel
            ext: .dmg
            
          - os: macos-latest
            target: aarch64-apple-darwin
            name: macos-apple-silicon
            ext: .dmg
            
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            name: linux
            ext: .AppImage

    runs-on: ${{ matrix.os }}
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8
          
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}
          
      - name: Install cargo-zigbuild (for cross-compilation)
        if: matrix.os == 'macos-latest' || matrix.os == 'ubuntu-latest'
        run: |
          cargo install cargo-zigbuild
          
      - name: Install Linux dependencies
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            librsvg2-dev \
            patchelf \
            libgtk-3-dev \
            libssl-dev
          # Try to install appindicator (use ayatana if available, fallback to older version)
          sudo apt-get install -y libayatana-appindicator3-dev || sudo apt-get install -y libappindicator3-dev
            
      # Certificates step removed - using ad-hoc signing instead
        
      - name: Update version (Unix)
        if: matrix.os != 'windows-latest'
        env:
          TAURI_UPDATER_PUBKEY: ${{ secrets.TAURI_UPDATER_PUBKEY }}
        run: |
          VERSION="${{ needs.create-release.outputs.version }}"
          echo "Setting version to: $VERSION"
          
          # Update package.json
          sed -i.bak "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" package.json || true
          sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" package.json || true
          
          # Update src-tauri/Cargo.toml
          sed -i.bak "s/^version = .*/version = \"$VERSION\"/" src-tauri/Cargo.toml || true
          sed -i "s/^version = .*/version = \"$VERSION\"/" src-tauri/Cargo.toml || true
          
          # Update tauri.conf.json version
          sed -i.bak "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" src-tauri/tauri.conf.json || true
          sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" src-tauri/tauri.conf.json || true
          
          # Inject the public key if available
          if [ -n "$TAURI_UPDATER_PUBKEY" ]; then
            sed -i.bak "s/PUBKEY_PLACEHOLDER_REPLACE_IN_CI/$TAURI_UPDATER_PUBKEY/" src-tauri/tauri.conf.json || true
            sed -i "s/PUBKEY_PLACEHOLDER_REPLACE_IN_CI/$TAURI_UPDATER_PUBKEY/" src-tauri/tauri.conf.json || true
          fi
          
      - name: Update version (Windows)
        if: matrix.os == 'windows-latest'
        env:
          TAURI_UPDATER_PUBKEY: ${{ secrets.TAURI_UPDATER_PUBKEY }}
        shell: pwsh
        run: |
          $VERSION = "${{ needs.create-release.outputs.version }}"
          Write-Host "Setting version to: $VERSION"
          
          # Update package.json
          $packageJson = Get-Content package.json -Raw | ConvertFrom-Json
          $packageJson.version = $VERSION
          $packageJson | ConvertTo-Json -Depth 10 | Set-Content -Path package.json -NoNewline
          
          # Update src-tauri/Cargo.toml
          $cargoContent = Get-Content src-tauri/Cargo.toml -Raw
          $cargoContent = $cargoContent -replace '(?m)^version = ".*"', "version = `"$VERSION`""
          Set-Content -Path src-tauri/Cargo.toml -Value $cargoContent -NoNewline
          
          # Update tauri.conf.json
          $configPath = "src-tauri/tauri.conf.json"
          $json = Get-Content $configPath -Raw
          $config = $json | ConvertFrom-Json
          $config.version = $VERSION
          
          # Update pubkey if available
          if ($env:TAURI_UPDATER_PUBKEY) {
            if (-not $config.plugins) { $config | Add-Member -NotePropertyName plugins -NotePropertyValue @{} }
            if (-not $config.plugins.updater) { $config.plugins | Add-Member -NotePropertyName updater -NotePropertyValue @{} }
            $config.plugins.updater.pubkey = $env:TAURI_UPDATER_PUBKEY
          }
          
          $newJson = $config | ConvertTo-Json -Depth 10
          Set-Content -Path $configPath -Value $newJson -NoNewline
          
      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            src-tauri
            src-helper
            
      - name: Install frontend dependencies
        run: pnpm install
        
      - name: Build helper binary (native)
        run: |
          cd src-helper
          cargo build --release --target ${{ matrix.target }}
          
      - name: Build helper binary for Linux (musl)
        if: matrix.os == 'macos-latest' || matrix.os == 'ubuntu-latest'
        run: |
          cd src-helper
          cargo zigbuild --release --target x86_64-unknown-linux-musl || true
        continue-on-error: true
        
      - name: Build Tauri app
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          pnpm tauri build --target ${{ matrix.target }}
          
      - name: Fix macOS signatures and recreate DMG
        if: matrix.os == 'macos-latest'
        run: |
          # Fix the app bundle signature
          ./scripts/fix-macos-signature.sh --ci
          
          # Recreate the DMG with the properly signed app
          ./scripts/recreate-dmg.sh ${{ matrix.target }} ${{ needs.create-release.outputs.version }}
          
      - name: Prepare artifacts (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          # Windows creates MSI installer
          mkdir -p dist
          cp src-tauri/target/${{ matrix.target }}/release/bundle/msi/*.msi dist/JaTerm_${{ needs.create-release.outputs.version }}_x64.msi || true
          # Also create NSIS installer if available
          cp src-tauri/target/${{ matrix.target }}/release/bundle/nsis/*.exe dist/JaTerm_${{ needs.create-release.outputs.version }}_x64-setup.exe || true
          
      - name: Prepare artifacts (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          # macOS creates DMG
          mkdir -p dist
          if [[ "${{ matrix.target }}" == "aarch64-apple-darwin" ]]; then
            cp src-tauri/target/${{ matrix.target }}/release/bundle/dmg/*.dmg dist/JaTerm_${{ needs.create-release.outputs.version }}_aarch64.dmg || true
          else
            cp src-tauri/target/${{ matrix.target }}/release/bundle/dmg/*.dmg dist/JaTerm_${{ needs.create-release.outputs.version }}_x64.dmg || true
          fi
          
      - name: Prepare artifacts (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          # Linux creates AppImage and deb
          mkdir -p dist
          cp src-tauri/target/${{ matrix.target }}/release/bundle/appimage/*.AppImage dist/JaTerm_${{ needs.create-release.outputs.version }}_amd64.AppImage || true
          cp src-tauri/target/${{ matrix.target }}/release/bundle/deb/*.deb dist/JaTerm_${{ needs.create-release.outputs.version }}_amd64.deb || true
          # Make AppImage executable
          chmod +x dist/*.AppImage || true
          
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: jaterm-${{ matrix.name }}
          path: dist/
          
      - name: Upload Release Assets
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.create-release.outputs.version }}
          files: dist/*
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}