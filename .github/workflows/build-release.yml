name: Build and Release

on:
  push:
    branches: [ main ]
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.0.0)'
        required: false
        type: string

# Give the workflow write permissions to create releases
permissions:
  contents: write
  packages: write

jobs:
  create-release:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get-version.outputs.version }}
      upload_url: ${{ steps.create-release.outputs.upload_url }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history and tags
          fetch-tags: true
      
      - name: Get version
        id: get-version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ inputs.version }}" ]]; then
            VERSION="${{ inputs.version }}"
          elif [[ "$GITHUB_REF" == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/v}
          elif [[ "$GITHUB_REF" == refs/heads/release/* ]]; then
            BASE=${GITHUB_REF#refs/heads/release/}
            DOY=$(date +%j)
            HOUR=$(date +%H)
            # For MSI, prerelease must be numeric only
            VERSION="$BASE-${DOY}${HOUR}"
          else
            # CI-only builds for non-release branches
            DOY=$(date +%j)
            HOUR=$(date +%H)
            # For MSI, prerelease must be numeric only
            VERSION="0.0.0-${DOY}${HOUR}"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"
          
      - name: Generate Release Notes
        id: release-notes
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          # Debug: Show available tags
          echo "=== Available tags (first 10) ==="
          git tag --sort=-version:refname | head -10 || echo "No tags found"
          
          echo "=== Current HEAD ==="
          git describe --exact-match --tags HEAD 2>/dev/null || echo "Not on a tag"
          
          # When running on a tag, get the PREVIOUS tag for comparison
          # If we're on a tag, git describe returns the current tag, so we need the one before it
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            # Get the second most recent tag
            LAST_TAG=$(git tag --sort=-version:refname | head -2 | tail -1 2>/dev/null || echo "")
            echo "Running on tag, using previous tag: $LAST_TAG"
            
            # Verify we got a different tag
            CURRENT_TAG="${{ github.ref_name }}"
            if [[ "$LAST_TAG" == "$CURRENT_TAG" ]]; then
              echo "ERROR: Previous tag is same as current tag!"
              echo "Attempting alternative method..."
              # Try to get the tag before the current one
              LAST_TAG=$(git tag --sort=-version:refname | grep -v "^${CURRENT_TAG}$" | head -1 || echo "")
              echo "Alternative previous tag: $LAST_TAG"
            fi
          else
            # On branch, get the most recent tag
            LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
            echo "Running on branch, using last tag: $LAST_TAG"
          fi
          echo "last_tag=$LAST_TAG" >> $GITHUB_OUTPUT
          
          # Try to generate AI release notes
          if [ -n "$OPENAI_API_KEY" ]; then
            echo "Generating AI release notes..."
            echo "OpenAI API key length: ${#OPENAI_API_KEY}"
            
            # Run with error output to see what's failing
            if node tools/generate-release-notes.mjs --since-tag --out release-notes.md 2>&1; then
              echo "AI release notes generated successfully"
              if [ -f release-notes.md ]; then
                CHANGELOG=$(cat release-notes.md)
                echo "Release notes content length: ${#CHANGELOG}"
              else
                echo "ERROR: release-notes.md file not created"
                CHANGELOG=""
              fi
            else
              echo "AI generation failed with exit code $?"
              echo "Falling back to git log"
              # Fallback to simple git log
              if [ -n "$LAST_TAG" ]; then
                CHANGELOG=$(git log $LAST_TAG..HEAD --pretty=format:"- %s" --no-merges | head -20)
              else
                CHANGELOG=$(git log --pretty=format:"- %s" --no-merges | head -20)
              fi
            fi
          else
            echo "WARNING: OPENAI_API_KEY not set in GitHub secrets, using git log fallback"
            # Fallback to simple git log
            if [ -n "$LAST_TAG" ]; then
              CHANGELOG=$(git log $LAST_TAG..HEAD --pretty=format:"- %s" --no-merges | head -20)
            else
              CHANGELOG=$(git log --pretty=format:"- %s" --no-merges | head -20)
            fi
          fi
          
          # Use heredoc for multi-line output (no escaping needed)
          {
            echo "changelog<<CHANGELOG_EOF"
            echo "$CHANGELOG"
            echo "CHANGELOG_EOF"
          } >> $GITHUB_OUTPUT
          
      - name: Create RC Release (release/* branch)
        id: create-release-rc
        if: startsWith(github.ref, 'refs/heads/release/')
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ steps.get-version.outputs.version }}
          name: JaTerm RC ${{ steps.get-version.outputs.version }}
          body: |
            ## JaTerm RC ${{ steps.get-version.outputs.version }}
            
            This is a release candidate intended for testing. It may contain changes that are not yet in the stable channel.
            
            ### üì¶ Installation
            
            #### Windows
            - **Installer**: Download `JaTerm_*.msi` for standard installation
            - **Portable**: Download `JaTerm_*-setup.exe` for NSIS installer
            
            #### macOS
            - **Intel**: Download `JaTerm_*_macos-intel.dmg`
            - **Apple Silicon**: Download `JaTerm_*_macos-apple-silicon.dmg`
            
            #### Linux
            - **AppImage**: Download `JaTerm_*.AppImage` (portable, no installation)
            - **Debian/Ubuntu**: Download `JaTerm_*.deb`
            
            ### üìù Recent Changes
            ${{ steps.release-notes.outputs.changelog }}
            
            ---
            [View all commits](https://github.com/${{ github.repository }}/compare/${{ steps.release-notes.outputs.last_tag }}...v${{ steps.get-version.outputs.version }})
          draft: false
          prerelease: true
          generate_release_notes: false

      - name: Create Stable Release (tag)
        id: create-release-tag
        if: startsWith(github.ref, 'refs/tags/v')
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ steps.get-version.outputs.version }}
          name: JaTerm v${{ steps.get-version.outputs.version }}
          body: |
            ## JaTerm v${{ steps.get-version.outputs.version }}
            
            ### üì¶ Installation
            
            #### Windows
            - **Installer**: Download `JaTerm_*.msi` for standard installation
            - **Portable**: Download `JaTerm_*-setup.exe` for NSIS installer
            
            #### macOS
            - **Intel**: Download `JaTerm_*_macos-intel.dmg`
            - **Apple Silicon**: Download `JaTerm_*_macos-apple-silicon.dmg`
            
            #### Linux
            - **AppImage**: Download `JaTerm_*.AppImage` (portable, no installation)
            - **Debian/Ubuntu**: Download `JaTerm_*.deb`
            
            ### üìù Recent Changes
            ${{ steps.release-notes.outputs.changelog }}
            
            ---
            [View all commits](https://github.com/${{ github.repository }}/compare/${{ steps.release-notes.outputs.last_tag }}...v${{ steps.get-version.outputs.version }})
          draft: false
          prerelease: false
          generate_release_notes: false

  build:
    needs: create-release
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            name: windows
            ext: .msi
            
          - os: macos-latest
            target: x86_64-apple-darwin
            name: macos-intel
            ext: .dmg
            
          - os: macos-latest
            target: aarch64-apple-darwin
            name: macos-apple-silicon
            ext: .dmg
            
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            name: linux
            ext: .AppImage

    runs-on: ${{ matrix.os }}
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history and tags
          fetch-tags: true
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8
          
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}
          
      - name: Install cargo-zigbuild (for cross-compilation)
        if: matrix.os == 'macos-latest' || matrix.os == 'ubuntu-latest'
        run: |
          cargo install cargo-zigbuild
          
      - name: Install Linux dependencies
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            librsvg2-dev \
            patchelf \
            libgtk-3-dev \
            libssl-dev
          # Try to install appindicator (use ayatana if available, fallback to older version)
          sudo apt-get install -y libayatana-appindicator3-dev || sudo apt-get install -y libappindicator3-dev
            
      - name: Import macOS certificate
        if: matrix.os == 'macos-latest'
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
        run: |
          # Create temporary keychain
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          
          echo "Creating keychain at: $KEYCHAIN_PATH"
          echo "Keychain password length: ${#KEYCHAIN_PASSWORD}"
          
          # Create keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH || { echo "Failed to create keychain"; exit 1; }
          echo "Keychain created successfully"
          
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH || { echo "Failed to set keychain settings"; exit 1; }
          echo "Keychain settings configured"
          
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH || { echo "Failed to unlock keychain"; exit 1; }
          echo "Keychain unlocked successfully"
          
          # Verify keychain is accessible
          security show-keychain-info $KEYCHAIN_PATH || { echo "Cannot access keychain info"; exit 1; }
          echo "Keychain is accessible"
          
          # Import certificate
          echo "$APPLE_CERTIFICATE" | base64 --decode > certificate.p12
          
          # Test certificate with openssl before importing
          echo "Testing certificate with openssl..."
          openssl pkcs12 -in certificate.p12 -passin pass:"$APPLE_CERTIFICATE_PASSWORD" -noout -info 2>&1 | head -5 || echo "OpenSSL verification failed"
          
          # Import the certificate - try the most reliable method
          echo "Importing certificate to keychain..."
          security import certificate.p12 -k $KEYCHAIN_PATH -P "$APPLE_CERTIFICATE_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security || echo "Import failed"
          
          # Extract the certificate for trust operations
          echo "Extracting certificate from P12..."
          openssl pkcs12 -in certificate.p12 -passin pass:"$APPLE_CERTIFICATE_PASSWORD" -nokeys -out cert.pem || echo "Failed to extract cert"
          
          # Trust the certificate for code signing (self-signed certificates need this)
          if [ -f cert.pem ]; then
            echo "Adding certificate to trusted list for code signing..."
            security add-trusted-cert -d -r trustAsRoot -p codeSign -k $KEYCHAIN_PATH cert.pem || echo "Failed to trust cert"
          fi
          
          # List keychains and add to search list
          echo "Adding keychain to search list:"
          security list-keychain -d user -s $KEYCHAIN_PATH login.keychain-db
          echo "Current keychain list:"
          security list-keychain -d user
          
          # Check what was imported
          echo "Checking imported identities:"
          security find-identity -v -p codesigning $KEYCHAIN_PATH || echo "No identities found"
          
          # Allow codesign to access keychain
          echo "Setting key partition list..."
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH || echo "Failed to set partition list"
          
          # Check again after partition list
          echo "Checking identities after partition list:"
          security find-identity -v -p codesigning $KEYCHAIN_PATH || echo "Still no identities found"
          
          # Find the actual signing identity - use the hash which is more reliable
          echo "Finding signing identity..."
          
          # Get the full output first for debugging
          IDENTITY_OUTPUT=$(security find-identity -v -p codesigning $KEYCHAIN_PATH)
          echo "Full identity output:"
          echo "$IDENTITY_OUTPUT"
          
          # Extract just the hash (40 hex characters) - this has no spaces
          CERT_HASH=$(echo "$IDENTITY_OUTPUT" | grep "1)" | head -1 | awk '{print $2}')
          # Extract the name for logging
          CERT_NAME=$(echo "$IDENTITY_OUTPUT" | grep "1)" | head -1 | sed 's/[^"]*"\([^"]*\)".*/\1/')
          
          # Check if we got a valid hash (should be 40 hex characters)
          if [ -n "$CERT_HASH" ] && [ "${#CERT_HASH}" -eq 40 ] && [[ "$CERT_HASH" =~ ^[A-Fa-f0-9]+$ ]]; then
            echo "Found valid certificate hash: $CERT_HASH"
            echo "Certificate name: $CERT_NAME"
            # Use the hash for signing - most reliable, no spaces
            ACTUAL_IDENTITY="$CERT_HASH"
          else
            echo "Warning: Could not find valid certificate hash (got: '$CERT_HASH')"
            # Check if there are NO valid identities at all
            if echo "$IDENTITY_OUTPUT" | grep -q "0 valid identities found"; then
              echo "ERROR: No valid code signing identities found!"
              echo "This is likely because the self-signed certificate lacks code signing capability"
              echo "Using ad-hoc signing as fallback (- means ad-hoc)"
              ACTUAL_IDENTITY="-"
            else
              # Try to extract the name carefully, preserving spaces
              CERT_NAME=$(echo "$IDENTITY_OUTPUT" | grep "1)" | head -1 | sed 's/[^"]*"\([^"]*\)".*/\1/')
              if [ -n "$CERT_NAME" ]; then
                echo "Found certificate name: '$CERT_NAME'"
                # As fallback, use the name
                ACTUAL_IDENTITY="$CERT_NAME"
              else
                echo "Warning: Could not find any identity, using ad-hoc signing"
                ACTUAL_IDENTITY="-"
              fi
            fi
          fi
          
          echo "Using signing identity: '$ACTUAL_IDENTITY'"
          echo "Identity length: ${#ACTUAL_IDENTITY}"
          
          # Also check default keychain
          echo "Checking default keychain for identities:"
          security find-identity -v -p codesigning || echo "No identities in default keychain"
          
          # Export for Tauri - GITHUB_ENV handles spaces without quotes
          # The value itself should not have quotes, just the shell assignment
          echo "APPLE_SIGNING_IDENTITY=$ACTUAL_IDENTITY" >> $GITHUB_ENV
          
          # Debug what was actually written
          echo "Exported to GITHUB_ENV: APPLE_SIGNING_IDENTITY='$ACTUAL_IDENTITY'"
          
          # Also export the keychain path for the build
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
        
      - name: Update version (Unix)
        if: matrix.os != 'windows-latest'
        env:
          TAURI_UPDATER_PUBKEY: ${{ vars.TAURI_UPDATER_PUBKEY }}
        run: |
          VERSION="${{ needs.create-release.outputs.version }}"
          echo "Setting version to: $VERSION"
          
          # Update package.json
          sed -i.bak "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" package.json || true
          sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" package.json || true
          
          # Update src-tauri/Cargo.toml
          sed -i.bak "s/^version = .*/version = \"$VERSION\"/" src-tauri/Cargo.toml || true
          sed -i "s/^version = .*/version = \"$VERSION\"/" src-tauri/Cargo.toml || true
          
          # Update tauri.conf.json version
          sed -i.bak "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" src-tauri/tauri.conf.json || true
          sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" src-tauri/tauri.conf.json || true
          
          # Inject the public key if available
          if [ -n "$TAURI_UPDATER_PUBKEY" ]; then
            sed -i.bak "s/PUBKEY_PLACEHOLDER_REPLACE_IN_CI/$TAURI_UPDATER_PUBKEY/" src-tauri/tauri.conf.json || true
            sed -i "s/PUBKEY_PLACEHOLDER_REPLACE_IN_CI/$TAURI_UPDATER_PUBKEY/" src-tauri/tauri.conf.json || true
          fi
          
      - name: Update version (Windows)
        if: matrix.os == 'windows-latest'
        env:
          TAURI_UPDATER_PUBKEY: ${{ vars.TAURI_UPDATER_PUBKEY }}
        shell: pwsh
        run: |
          $VERSION = "${{ needs.create-release.outputs.version }}"
          Write-Host "Setting version to: $VERSION"
          
          # Update package.json
          $packageJson = Get-Content package.json -Raw | ConvertFrom-Json
          $packageJson.version = $VERSION
          $packageJson | ConvertTo-Json -Depth 10 | Set-Content -Path package.json -NoNewline
          
          # Update src-tauri/Cargo.toml
          $cargoContent = Get-Content src-tauri/Cargo.toml -Raw
          $cargoContent = $cargoContent -replace '(?m)^version = ".*"', "version = `"$VERSION`""
          Set-Content -Path src-tauri/Cargo.toml -Value $cargoContent -NoNewline
          
          # Update tauri.conf.json
          $configPath = "src-tauri/tauri.conf.json"
          $json = Get-Content $configPath -Raw
          $config = $json | ConvertFrom-Json
          $config.version = $VERSION
          
          # Update pubkey if available (under plugins.updater.pubkey)
          if ($env:TAURI_UPDATER_PUBKEY) {
            if (-not $config.plugins) { $config | Add-Member -NotePropertyName plugins -NotePropertyValue @{} }
            if (-not $config.plugins.updater) { $config.plugins | Add-Member -NotePropertyName updater -NotePropertyValue @{} }
            $config.plugins.updater.pubkey = $env:TAURI_UPDATER_PUBKEY
          }
          
          $newJson = $config | ConvertTo-Json -Depth 10
          Set-Content -Path $configPath -Value $newJson -NoNewline
          
      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            src-tauri
            src-helper
            
      - name: Install frontend dependencies
        run: pnpm install
        
      - name: Build helper binary (native)
        run: |
          cd src-helper
          cargo build --release --target ${{ matrix.target }}
          
      - name: Build helper binary for Linux (musl)
        if: matrix.os == 'macos-latest' || matrix.os == 'ubuntu-latest'
        run: |
          cd src-helper
          cargo zigbuild --release --target x86_64-unknown-linux-musl || true
        continue-on-error: true
        
      - name: Prepare keychain for build (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          echo "Ensuring keychain is accessible for build..."
          # Use the keychain path from environment
          if [ -n "$KEYCHAIN_PATH" ]; then
            echo "Using keychain at: $KEYCHAIN_PATH"
            
            # Make sure it's the default keychain for this session
            security default-keychain -s $KEYCHAIN_PATH
            echo "Set as default keychain"
            
            # Make sure it's in the search list (put it first)
            security list-keychain -d user -s $KEYCHAIN_PATH login.keychain-db
            echo "Added to keychain search list"
            
            # No need to unlock with wrong password - it's already unlocked
            # Just verify it's accessible
            security show-keychain-info $KEYCHAIN_PATH || echo "Warning: Cannot access keychain"
            
            # Verify the identity is still there
            echo "Verifying signing identity..."
            security find-identity -v -p codesigning $KEYCHAIN_PATH || echo "Warning: No identities found in custom keychain"
            
            # Show what identity we're using (with quotes to show spaces)
            echo "APPLE_SIGNING_IDENTITY to be used: '$APPLE_SIGNING_IDENTITY'"
            echo "Identity length: ${#APPLE_SIGNING_IDENTITY}"
            
            # Verify the specific identity exists - handle both hash and name
            if [ -n "$APPLE_SIGNING_IDENTITY" ]; then
              # Remove quotes if present for grep
              IDENTITY_TO_CHECK=$(echo "$APPLE_SIGNING_IDENTITY" | sed 's/"//g')
              echo "Checking for identity: '$IDENTITY_TO_CHECK'"
              security find-identity -v -p codesigning $KEYCHAIN_PATH | grep -F "$IDENTITY_TO_CHECK" || echo "Warning: Specific identity not found"
            fi
          else
            echo "Warning: KEYCHAIN_PATH not set in environment"
          fi
          
          # Remove test binary that shouldn't be signed in release builds
          echo "Removing test_keyring binary from release build..."
          rm -f src-tauri/src/bin/test_keyring.rs
      
      - name: Verify signing keys (bash)
        if: matrix.os != 'windows-latest'
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          TAURI_UPDATER_PUBKEY: ${{ vars.TAURI_UPDATER_PUBKEY }}
        shell: bash
        run: |
          echo "====== Verifying Tauri Signing Keys ======"
          
          # Verify public key MD5
          if [ -n "$TAURI_UPDATER_PUBKEY" ]; then
            PUBKEY_MD5=$(echo -n "$TAURI_UPDATER_PUBKEY" | md5 || echo -n "$TAURI_UPDATER_PUBKEY" | md5sum | cut -d' ' -f1)
            echo "Public key MD5: $PUBKEY_MD5"
            echo "Expected: 1a1310bf394ca140c55cc01610e020b1"
            if [ "$PUBKEY_MD5" != "1a1310bf394ca140c55cc01610e020b1" ]; then
              echo "WARNING: Public key MD5 mismatch!"
            fi
          else
            echo "ERROR: No public key found in TAURI_UPDATER_PUBKEY!"
            exit 1
          fi
          
          # Verify private key exists (hash it to check)
          if [ -n "$TAURI_SIGNING_PRIVATE_KEY" ]; then
            PRIVKEY_MD5=$(echo -n "$TAURI_SIGNING_PRIVATE_KEY" | md5 || echo -n "$TAURI_SIGNING_PRIVATE_KEY" | md5sum | cut -d' ' -f1)
            echo "Private key MD5: $PRIVKEY_MD5"
            echo "Private key length: ${#TAURI_SIGNING_PRIVATE_KEY}"
            # NOTE: Add your expected MD5 here after testing locally
            # echo "Expected: YOUR_PRIVATE_KEY_MD5"
          else
            echo "ERROR: No private key found in TAURI_SIGNING_PRIVATE_KEY!"
            exit 1
          fi
          
          # Verify password exists (hash it)
          if [ -n "$TAURI_SIGNING_PRIVATE_KEY_PASSWORD" ]; then
            PASSWORD_MD5=$(echo -n "$TAURI_SIGNING_PRIVATE_KEY_PASSWORD" | md5 || echo -n "$TAURI_SIGNING_PRIVATE_KEY_PASSWORD" | md5sum | cut -d' ' -f1)
            echo "Password MD5: $PASSWORD_MD5"
            echo "Password length: ${#TAURI_SIGNING_PRIVATE_KEY_PASSWORD}"
            # NOTE: Add your expected MD5 here after testing locally
            # echo "Expected: YOUR_PASSWORD_MD5"
          else
            echo "ERROR: No password found in TAURI_SIGNING_PRIVATE_KEY_PASSWORD!"
            exit 1
          fi
          
          echo "====== Keys verification complete ======"
      
      - name: Verify signing keys (Windows)
        if: matrix.os == 'windows-latest'
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          TAURI_UPDATER_PUBKEY: ${{ vars.TAURI_UPDATER_PUBKEY }}
        shell: pwsh
        run: |
          Write-Output "====== Verifying Tauri Signing Keys ======"
          
          # Verify public key MD5
          if ($env:TAURI_UPDATER_PUBKEY) {
            $bytes = [System.Text.Encoding]::UTF8.GetBytes($env:TAURI_UPDATER_PUBKEY)
            $md5 = [System.Security.Cryptography.MD5]::Create()
            $hash = $md5.ComputeHash($bytes)
            $PUBKEY_MD5 = [System.BitConverter]::ToString($hash) -replace '-', '' | ForEach-Object { $_.ToLower() }
            Write-Output "Public key MD5: $PUBKEY_MD5"
            Write-Output "Expected: 1a1310bf394ca140c55cc01610e020b1"
            if ($PUBKEY_MD5 -ne "1a1310bf394ca140c55cc01610e020b1") {
              Write-Output "WARNING: Public key MD5 mismatch!"
            }
          } else {
            Write-Output "ERROR: No public key found in TAURI_UPDATER_PUBKEY!"
            exit 1
          }
          
          # Verify private key exists (hash it to check)
          if ($env:TAURI_SIGNING_PRIVATE_KEY) {
            $bytes = [System.Text.Encoding]::UTF8.GetBytes($env:TAURI_SIGNING_PRIVATE_KEY)
            $md5 = [System.Security.Cryptography.MD5]::Create()
            $hash = $md5.ComputeHash($bytes)
            $PRIVKEY_MD5 = [System.BitConverter]::ToString($hash) -replace '-', '' | ForEach-Object { $_.ToLower() }
            Write-Output "Private key MD5: $PRIVKEY_MD5"
            Write-Output "Private key length: $($env:TAURI_SIGNING_PRIVATE_KEY.Length)"
            # NOTE: Add your expected MD5 here after testing locally
            # Write-Output "Expected: YOUR_PRIVATE_KEY_MD5"
          } else {
            Write-Output "ERROR: No private key found in TAURI_SIGNING_PRIVATE_KEY!"
            exit 1
          }
          
          # Verify password exists (hash it)
          if ($env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD) {
            $bytes = [System.Text.Encoding]::UTF8.GetBytes($env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD)
            $md5 = [System.Security.Cryptography.MD5]::Create()
            $hash = $md5.ComputeHash($bytes)
            $PASSWORD_MD5 = [System.BitConverter]::ToString($hash) -replace '-', '' | ForEach-Object { $_.ToLower() }
            Write-Output "Password MD5: $PASSWORD_MD5"
            Write-Output "Password length: $($env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD.Length)"
            # NOTE: Add your expected MD5 here after testing locally
            # Write-Output "Expected: YOUR_PASSWORD_MD5"
          } else {
            Write-Output "ERROR: No password found in TAURI_SIGNING_PRIVATE_KEY_PASSWORD!"
            exit 1
          }
          
          Write-Output "====== Keys verification complete ====="
      
      - name: Build Tauri app (Unix)
        if: matrix.os != 'windows-latest'
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ env.APPLE_SIGNING_IDENTITY }}
        shell: bash
        run: |
          echo "Building with Tauri signing enabled..."
          echo "Private key is set: $([ -n "$TAURI_SIGNING_PRIVATE_KEY" ] && echo 'YES' || echo 'NO')"
          echo "Password is set: $([ -n "$TAURI_SIGNING_PRIVATE_KEY_PASSWORD" ] && echo 'YES' || echo 'NO')"
          
          # Explicitly enable updater signatures
          export TAURI_PRIVATE_KEY="$TAURI_SIGNING_PRIVATE_KEY"
          export TAURI_KEY_PASSWORD="$TAURI_SIGNING_PRIVATE_KEY_PASSWORD"
          
          pnpm tauri build --target ${{ matrix.target }}
          
          echo "Build complete. Looking for signature files..."
          echo "=== All .sig files in target directory ==="
          find src-tauri/target -name "*.sig" -type f 2>/dev/null || echo "No .sig files found"
          
          # If no signatures found, list what files were created
          if ! find src-tauri/target -name "*.sig" -type f 2>/dev/null | grep -q .; then
            echo "WARNING: No signature files generated!"
            echo "Checking if updater artifacts were created:"
            find src-tauri/target -name "*.tar.gz" -o -name "*.zip" -o -name "*.AppImage" -o -name "*.msi" -o -name "*.exe" -o -name "*.dmg" -o -name "*.deb" | head -20
          fi
          
          echo "=== Bundle directory contents ==="
          ls -la src-tauri/target/${{ matrix.target }}/release/bundle/ || true
          
          # Platform-specific signature checks
          if [[ "${{ matrix.os }}" == "macos-latest" ]]; then
            echo "=== macOS bundle directory ==="
            ls -la src-tauri/target/${{ matrix.target }}/release/bundle/macos/ || true
          elif [[ "${{ matrix.os }}" == "ubuntu-latest" ]]; then
            echo "=== Linux AppImage directory ==="
            ls -la src-tauri/target/${{ matrix.target }}/release/bundle/appimage/ || true
          fi

      - name: Build Tauri app (Windows)
        if: matrix.os == 'windows-latest'
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        shell: pwsh
        run: |
          Write-Output "Building with Tauri signing enabled..."
          $keySet = if ($env:TAURI_SIGNING_PRIVATE_KEY) { "YES" } else { "NO" }
          $passSet = if ($env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD) { "YES" } else { "NO" }
          Write-Output "Private key is set: $keySet"
          Write-Output "Password is set: $passSet"
          
          # Also set alternative env vars that Tauri might use
          $env:TAURI_PRIVATE_KEY = $env:TAURI_SIGNING_PRIVATE_KEY
          $env:TAURI_KEY_PASSWORD = $env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD
          
          pnpm tauri build --target ${{ matrix.target }}
          
          Write-Output "Build complete. Looking for signature files..."
          Write-Output "=== All .sig files in target directory ==="
          $sigFiles = Get-ChildItem -Path "src-tauri\target" -Filter "*.sig" -Recurse -ErrorAction SilentlyContinue
          if ($sigFiles) {
            $sigFiles | ForEach-Object { Write-Output $_.FullName }
          } else {
            Write-Output "WARNING: No .sig files found!"
            Write-Output "Checking what files were created:"
            Get-ChildItem -Path "src-tauri\target" -Include "*.msi","*.exe","*.zip" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 10 | ForEach-Object { Write-Output $_.FullName }
          }
          
          Write-Output "=== Bundle directory contents ==="
          Get-ChildItem -Path "src-tauri\target\${{ matrix.target }}\release\bundle\" -ErrorAction SilentlyContinue
          
          Write-Output "=== Windows MSI directory ==="
          Get-ChildItem -Path "src-tauri\target\${{ matrix.target }}\release\bundle\msi\" -ErrorAction SilentlyContinue

      - name: Package helper (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path dist | Out-Null
          $helper = "src-helper/target/${{ matrix.target }}/release/jaterm-agent.exe"
          if (Test-Path $helper) { Copy-Item $helper -Destination "dist/jaterm-agent_windows_x64.exe" }
          
      - name: Fix macOS signatures and recreate DMG
        if: matrix.os == 'macos-latest'
        run: |
          # Fix the app bundle signature
          ./scripts/fix-macos-signature.sh --ci
          
          # Recreate the DMG with the properly signed app
          ./scripts/recreate-dmg.sh ${{ matrix.target }} ${{ needs.create-release.outputs.version }}
          
      - name: Prepare artifacts (Windows)
        if: matrix.os == 'windows-latest'
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        shell: pwsh
        run: |
          # Windows creates MSI installer
          New-Item -ItemType Directory -Force -Path dist | Out-Null
          
          # Debug: Show what's in the MSI directory
          Write-Host "=== MSI Directory Contents ==="
          Get-ChildItem -Path "src-tauri\target\${{ matrix.target }}\release\bundle\msi\" -ErrorAction SilentlyContinue | Format-Table Name, Length
          
          # Copy MSI installer
          $msiFiles = Get-ChildItem -Path "src-tauri\target\${{ matrix.target }}\release\bundle\msi\*.msi" -ErrorAction SilentlyContinue
          if ($msiFiles) {
            $msiFile = $msiFiles[0]
            Copy-Item $msiFile -Destination "dist\JaTerm_${{ needs.create-release.outputs.version }}_x64.msi"
            Write-Host "Copied MSI: $($msiFile.Name)"
            
            # Look for signature with exact name match
            $sigPath = $msiFile.FullName + ".sig"
            Write-Host "Looking for signature at: $sigPath"
            if (Test-Path $sigPath) {
              Copy-Item $sigPath -Destination "dist\JaTerm_${{ needs.create-release.outputs.version }}_x64.msi.sig"
              Write-Host "Copied signature file!"
            } else {
              Write-Host "WARNING: No signature file found at $sigPath"
              # Try alternative locations
              $altSigFiles = Get-ChildItem -Path "src-tauri\target\${{ matrix.target }}\release\bundle\msi\*.sig" -ErrorAction SilentlyContinue
              if ($altSigFiles) {
                Write-Host "Found alternative signature files:"
                $altSigFiles | ForEach-Object { Write-Host "  - $($_.Name)" }
                Copy-Item $altSigFiles[0] -Destination "dist\JaTerm_${{ needs.create-release.outputs.version }}_x64.msi.sig"
                Write-Host "Copied alternative signature: $($altSigFiles[0].Name)"
              } elseif ($env:TAURI_SIGNING_PRIVATE_KEY) {
                Write-Host "Attempting to generate MSI signature manually..."
                try {
                  # Debug: Check key format
                  $keyStart = $env:TAURI_SIGNING_PRIVATE_KEY.Substring(0, [Math]::Min(20, $env:TAURI_SIGNING_PRIVATE_KEY.Length))
                  Write-Host "Key starts with: $($keyStart -replace '.', '*')" # Masked for security
                  
                  # Clean up the key - remove any prefixes and whitespace
                  $cleanKey = $env:TAURI_SIGNING_PRIVATE_KEY
                  # Remove common prefixes if present
                  $cleanKey = $cleanKey -replace '^base64:', ''
                  $cleanKey = $cleanKey -replace '^data:.*base64,', ''
                  $cleanKey = $cleanKey.Trim()
                  
                  # Create a temporary file with the private key
                  $keyFile = New-TemporaryFile
                  [System.IO.File]::WriteAllText($keyFile.FullName, $cleanKey, [System.Text.Encoding]::UTF8)
                  # Sign the MSI file
                  $msiPath = "dist\JaTerm_${{ needs.create-release.outputs.version }}_x64.msi"
                  Write-Host "Signing MSI at: $msiPath"
                  & pnpm tauri signer sign --private-key "$keyFile" --password "$env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD" "$msiPath"
                  Remove-Item $keyFile
                } catch {
                  Write-Host "WARNING: Failed to sign MSI: $_"
                }
              }
            }
          }
          
          # Copy NSIS installer if available
          $exeFiles = Get-ChildItem -Path "src-tauri\target\${{ matrix.target }}\release\bundle\nsis\*.exe" -ErrorAction SilentlyContinue
          if ($exeFiles) {
            Copy-Item $exeFiles[0] -Destination "dist\JaTerm_${{ needs.create-release.outputs.version }}_x64-setup.exe"
            
            # Sign the NSIS installer if we have signing keys
            if ($env:TAURI_SIGNING_PRIVATE_KEY) {
              Write-Host "Signing NSIS installer..."
              try {
                # Debug: Check key format
                $keyStart = $env:TAURI_SIGNING_PRIVATE_KEY.Substring(0, [Math]::Min(20, $env:TAURI_SIGNING_PRIVATE_KEY.Length))
                Write-Host "Key starts with: $($keyStart -replace '.', '*')" # Masked for security
                
                # Clean up the key - remove any prefixes and whitespace
                $cleanKey = $env:TAURI_SIGNING_PRIVATE_KEY
                # Remove common prefixes if present
                $cleanKey = $cleanKey -replace '^base64:', ''
                $cleanKey = $cleanKey -replace '^data:.*base64,', ''
                $cleanKey = $cleanKey.Trim()
                
                $keyFile = New-TemporaryFile
                [System.IO.File]::WriteAllText($keyFile.FullName, $cleanKey, [System.Text.Encoding]::UTF8)
                $exePath = "dist\JaTerm_${{ needs.create-release.outputs.version }}_x64-setup.exe"
                Write-Host "Signing NSIS at: $exePath"
                & pnpm tauri signer sign --private-key "$keyFile" --password "$env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD" "$exePath"
                Remove-Item $keyFile
              } catch {
                Write-Host "WARNING: Failed to sign NSIS: $_"
              }
            }
          }
          
          # Final check of dist directory
          Write-Host "=== Final dist directory contents ==="
          Get-ChildItem -Path "dist\" | Format-Table Name, Length
          
      - name: Prepare artifacts (macOS)
        if: matrix.os == 'macos-latest'
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          # macOS creates DMG and app.tar.gz for updater
          mkdir -p dist
          
          echo "=== Checking bundle directory before processing ==="
          ls -la src-tauri/target/${{ matrix.target }}/release/bundle/macos/ || true
          
          if [[ "${{ matrix.target }}" == "aarch64-apple-darwin" ]]; then
            # Copy DMG for manual installation
            cp src-tauri/target/${{ matrix.target }}/release/bundle/dmg/*.dmg dist/JaTerm_${{ needs.create-release.outputs.version }}_aarch64.dmg || true
            
            # Sign the DMG if we have signing keys
            if [[ -n "$TAURI_SIGNING_PRIVATE_KEY" ]] && [[ -f "dist/JaTerm_${{ needs.create-release.outputs.version }}_aarch64.dmg" ]]; then
              echo "Signing DMG file..."
              echo "$TAURI_SIGNING_PRIVATE_KEY" | pnpm tauri signer sign --private-key - --password "$TAURI_SIGNING_PRIVATE_KEY_PASSWORD" "dist/JaTerm_${{ needs.create-release.outputs.version }}_aarch64.dmg" || echo "DMG signing failed"
            fi
            
            # Check if app.tar.gz already exists (Tauri might create it)
            if [[ -f "src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app.tar.gz" ]]; then
              echo "Found existing app.tar.gz, copying..."
              cp src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app.tar.gz dist/JaTerm_${{ needs.create-release.outputs.version }}_aarch64.app.tar.gz
            elif [[ -d "src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app" ]]; then
              # Create app.tar.gz for auto-updater
              echo "Creating app.tar.gz from JaTerm.app..."
              cd src-tauri/target/${{ matrix.target }}/release/bundle/macos/
              tar czf JaTerm.app.tar.gz JaTerm.app
              cd -
              cp src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app.tar.gz dist/JaTerm_${{ needs.create-release.outputs.version }}_aarch64.app.tar.gz
            fi
            
            # Look for signature file
            echo "Looking for signature files..."
            if [[ -f "src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app.tar.gz.sig" ]]; then
              echo "Found JaTerm.app.tar.gz.sig, copying..."
              cp src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app.tar.gz.sig dist/JaTerm_${{ needs.create-release.outputs.version }}_aarch64.app.tar.gz.sig
            else
              echo "WARNING: No signature file found at src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app.tar.gz.sig"
              # Check for any .sig files
              find src-tauri/target/${{ matrix.target }}/release/bundle/macos/ -name "*.sig" -type f || echo "No .sig files in macos bundle"
              
              # If we have signing keys and the tar.gz exists, generate signature manually
              if [[ -n "$TAURI_SIGNING_PRIVATE_KEY" ]] && [[ -f "dist/JaTerm_${{ needs.create-release.outputs.version }}_aarch64.app.tar.gz" ]]; then
                echo "Attempting to generate signature manually..."
                # Use tauri signer to generate signature
                echo "$TAURI_SIGNING_PRIVATE_KEY" | pnpm tauri signer sign --private-key - --password "$TAURI_SIGNING_PRIVATE_KEY_PASSWORD" "dist/JaTerm_${{ needs.create-release.outputs.version }}_aarch64.app.tar.gz" || echo "Manual signing failed"
              fi
            fi
            
            # Copy helper (Apple Silicon)
            if [[ -f "src-helper/target/${{ matrix.target }}/release/jaterm-agent" ]]; then
              cp "src-helper/target/${{ matrix.target }}/release/jaterm-agent" "dist/jaterm-agent_macos_aarch64"
              chmod +x dist/jaterm-agent_macos_aarch64 || true
            fi
          else
            # Copy DMG for manual installation
            cp src-tauri/target/${{ matrix.target }}/release/bundle/dmg/*.dmg dist/JaTerm_${{ needs.create-release.outputs.version }}_x64.dmg || true
            
            # Sign the DMG if we have signing keys
            if [[ -n "$TAURI_SIGNING_PRIVATE_KEY" ]] && [[ -f "dist/JaTerm_${{ needs.create-release.outputs.version }}_x64.dmg" ]]; then
              echo "Signing DMG file..."
              echo "$TAURI_SIGNING_PRIVATE_KEY" | pnpm tauri signer sign --private-key - --password "$TAURI_SIGNING_PRIVATE_KEY_PASSWORD" "dist/JaTerm_${{ needs.create-release.outputs.version }}_x64.dmg" || echo "DMG signing failed"
            fi
            
            # Check if app.tar.gz already exists (Tauri might create it)
            if [[ -f "src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app.tar.gz" ]]; then
              echo "Found existing app.tar.gz, copying..."
              cp src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app.tar.gz dist/JaTerm_${{ needs.create-release.outputs.version }}_x64.app.tar.gz
            elif [[ -d "src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app" ]]; then
              # Create app.tar.gz for auto-updater
              echo "Creating app.tar.gz from JaTerm.app..."
              cd src-tauri/target/${{ matrix.target }}/release/bundle/macos/
              tar czf JaTerm.app.tar.gz JaTerm.app
              cd -
              cp src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app.tar.gz dist/JaTerm_${{ needs.create-release.outputs.version }}_x64.app.tar.gz
            fi
            
            # Look for signature file
            echo "Looking for signature files..."
            if [[ -f "src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app.tar.gz.sig" ]]; then
              echo "Found JaTerm.app.tar.gz.sig, copying..."
              cp src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app.tar.gz.sig dist/JaTerm_${{ needs.create-release.outputs.version }}_x64.app.tar.gz.sig
            else
              echo "WARNING: No signature file found at src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app.tar.gz.sig"
              # Check for any .sig files
              find src-tauri/target/${{ matrix.target }}/release/bundle/macos/ -name "*.sig" -type f || echo "No .sig files in macos bundle"
              
              # If we have signing keys and the tar.gz exists, generate signature manually
              if [[ -n "$TAURI_SIGNING_PRIVATE_KEY" ]] && [[ -f "dist/JaTerm_${{ needs.create-release.outputs.version }}_x64.app.tar.gz" ]]; then
                echo "Attempting to generate signature manually..."
                # Use tauri signer to generate signature
                echo "$TAURI_SIGNING_PRIVATE_KEY" | pnpm tauri signer sign --private-key - --password "$TAURI_SIGNING_PRIVATE_KEY_PASSWORD" "dist/JaTerm_${{ needs.create-release.outputs.version }}_x64.app.tar.gz" || echo "Manual signing failed"
              fi
            fi
            
            # Copy helper (Intel)
            if [[ -f "src-helper/target/${{ matrix.target }}/release/jaterm-agent" ]]; then
              cp "src-helper/target/${{ matrix.target }}/release/jaterm-agent" "dist/jaterm-agent_macos_x64"
              chmod +x dist/jaterm-agent_macos_x64 || true
            fi
          fi
          
          echo "=== Final dist directory contents ==="
          ls -la dist/
          
      - name: Prepare artifacts (Linux)
        if: matrix.os == 'ubuntu-latest'
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          # Linux creates AppImage and deb
          mkdir -p dist
          
          echo "=== Checking AppImage directory ==="
          ls -la src-tauri/target/${{ matrix.target }}/release/bundle/appimage/ || true
          
          # Copy AppImage for updater
          APPIMAGE=$(find src-tauri/target/${{ matrix.target }}/release/bundle/appimage/ -name "*.AppImage" -type f | head -1)
          if [[ -n "$APPIMAGE" ]]; then
            echo "Found AppImage: $APPIMAGE"
            cp "$APPIMAGE" "dist/JaTerm_${{ needs.create-release.outputs.version }}_amd64.AppImage"
            
            # Look for signature file
            SIGFILE="${APPIMAGE}.sig"
            echo "Looking for signature at: $SIGFILE"
            if [[ -f "$SIGFILE" ]]; then
              echo "Found signature, copying..."
              cp "$SIGFILE" "dist/JaTerm_${{ needs.create-release.outputs.version }}_amd64.AppImage.sig"
            else
              echo "WARNING: No signature file found at $SIGFILE"
              # Check for any .sig files
              find src-tauri/target/${{ matrix.target }}/release/bundle/appimage/ -name "*.sig" -type f || echo "No .sig files found"
              
              # If we have signing keys and the AppImage exists, generate signature manually
              if [[ -n "$TAURI_SIGNING_PRIVATE_KEY" ]] && [[ -f "dist/JaTerm_${{ needs.create-release.outputs.version }}_amd64.AppImage" ]]; then
                echo "Attempting to generate signature manually..."
                # Use tauri signer to generate signature
                echo "$TAURI_SIGNING_PRIVATE_KEY" | pnpm tauri signer sign --private-key - --password "$TAURI_SIGNING_PRIVATE_KEY_PASSWORD" "dist/JaTerm_${{ needs.create-release.outputs.version }}_amd64.AppImage" || echo "Manual signing failed"
              fi
            fi
          fi
          
          # Copy deb package
          cp src-tauri/target/${{ matrix.target }}/release/bundle/deb/*.deb dist/JaTerm_${{ needs.create-release.outputs.version }}_amd64.deb || true
          
          # Sign the deb package if we have signing keys
          if [[ -n "$TAURI_SIGNING_PRIVATE_KEY" ]] && [[ -f "dist/JaTerm_${{ needs.create-release.outputs.version }}_amd64.deb" ]]; then
            echo "Signing deb package..."
            echo "$TAURI_SIGNING_PRIVATE_KEY" | pnpm tauri signer sign --private-key - --password "$TAURI_SIGNING_PRIVATE_KEY_PASSWORD" "dist/JaTerm_${{ needs.create-release.outputs.version }}_amd64.deb" || echo "Deb signing failed"
          fi
          
          # Make AppImage executable
          chmod +x dist/*.AppImage || true
          # Copy helper (gnu)
          if [[ -f "src-helper/target/${{ matrix.target }}/release/jaterm-agent" ]]; then
            cp "src-helper/target/${{ matrix.target }}/release/jaterm-agent" "dist/jaterm-agent_linux_x86_64"
            chmod +x dist/jaterm-agent_linux_x86_64 || true
          fi
          # Copy helper (musl) if built via zigbuild
          if [[ -f "src-helper/target/x86_64-unknown-linux-musl/release/jaterm-agent" ]]; then
            cp "src-helper/target/x86_64-unknown-linux-musl/release/jaterm-agent" "dist/jaterm-agent_linux_x86_64_musl"
            chmod +x dist/jaterm-agent_linux_x86_64_musl || true
          fi
          
          echo "=== Final dist directory contents ==="
          ls -la dist/
          
      - name: Verify signatures exist
        shell: bash
        run: |
          echo "=== Verifying signatures for all release artifacts ==="
          MISSING_SIGS=""
          
          # Check each artifact type that needs a signature
          for file in dist/*.dmg dist/*.AppImage dist/*.deb dist/*.msi dist/*.exe dist/*.tar.gz; do
            if [[ -f "$file" ]]; then
              filename=$(basename "$file")
              # Skip signature files themselves and helper binaries
              if [[ ! "$filename" =~ \.sig$ ]] && [[ ! "$filename" =~ ^jaterm-agent ]]; then
                if [[ ! -f "${file}.sig" ]]; then
                  echo "WARNING: Missing signature for $filename"
                  MISSING_SIGS="$MISSING_SIGS $filename"
                else
                  echo "‚úì Found signature for $filename"
                fi
              fi
            fi
          done
          
          if [[ -n "$MISSING_SIGS" ]]; then
            echo "ERROR: Missing signatures for:$MISSING_SIGS"
            echo "This will cause auto-updater to fail!"
            # Don't fail the build, but make it very visible
            echo "::warning::Missing signature files for:$MISSING_SIGS"
          else
            echo "All artifacts have signatures!"
          fi
          
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: jaterm-${{ matrix.name }}
          path: dist/
          
      - name: Upload Release Assets
        if: startsWith(github.ref, 'refs/tags/v') || startsWith(github.ref, 'refs/heads/release/')
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.create-release.outputs.version }}
          files: dist/*
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  generate-latest-json:
    needs: [create-release, build]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v') || startsWith(github.ref, 'refs/heads/release/')
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history and tags
          fetch-tags: true
      
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/
          
      - name: Prepare dist directory
        run: |
          mkdir -p dist
          # Copy all artifacts to dist, flattening the structure
          find artifacts -type f \( -name "*.msi" -o -name "*.AppImage" -o -name "*.dmg" -o -name "*.exe" -o -name "*.deb" -o -name "*.sig" -o -name "*.tar.gz" \) -exec cp {} dist/ \;
          ls -la dist/
          
      - name: Generate latest.json
        run: |
          VERSION="${{ needs.create-release.outputs.version }}"
          echo "Generating latest.json for version ${VERSION}"
          
          # Make script executable
          chmod +x scripts/generate-latest-json.sh
          
          # Generate latest.json
          ./scripts/generate-latest-json.sh "${VERSION}" "JaTerm ${VERSION} - Check the release page for details"
          
          # Verify it was created
          if [ -f dist/latest.json ]; then
            echo "latest.json generated successfully:"
            cat dist/latest.json
          else
            echo "Error: latest.json was not generated!"
            exit 1
          fi
          
      - name: Upload latest.json to Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.create-release.outputs.version }}
          files: dist/latest.json
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
