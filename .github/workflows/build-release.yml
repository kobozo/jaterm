name: Build and Release

on:
  push:
    branches: [ main ]
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.0.0)'
        required: false
        type: string

# Give the workflow write permissions to create releases
permissions:
  contents: write
  packages: write

jobs:
  create-release:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get-version.outputs.version }}
      upload_url: ${{ steps.create-release.outputs.upload_url }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Get version
        id: get-version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ inputs.version }}" ]]; then
            VERSION="${{ inputs.version }}"
          elif [[ "$GITHUB_REF" == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/v}
          elif [[ "$GITHUB_REF" == refs/heads/release/* ]]; then
            BASE=${GITHUB_REF#refs/heads/release/}
            DOY=$(date +%j)
            HOUR=$(date +%H)
            # For MSI, prerelease must be numeric only
            VERSION="$BASE-${DOY}${HOUR}"
          else
            # CI-only builds for non-release branches
            DOY=$(date +%j)
            HOUR=$(date +%H)
            # For MSI, prerelease must be numeric only
            VERSION="0.0.0-${DOY}${HOUR}"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"
          
      - name: Generate Release Notes
        id: release-notes
        run: |
          # Get the last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          # Generate changelog
          if [ -n "$LAST_TAG" ]; then
            CHANGELOG=$(git log $LAST_TAG..HEAD --pretty=format:"- %s" --no-merges | head -20)
          else
            CHANGELOG=$(git log --pretty=format:"- %s" --no-merges | head -20)
          fi
          
          # Escape for GitHub Actions
          CHANGELOG="${CHANGELOG//'%'/'%25'}"
          CHANGELOG="${CHANGELOG//$'\n'/'%0A'}"
          CHANGELOG="${CHANGELOG//$'\r'/'%0D'}"
          
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
      - name: Create RC Release (release/* branch)
        id: create-release-rc
        if: startsWith(github.ref, 'refs/heads/release/')
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ steps.get-version.outputs.version }}
          name: JaTerm RC ${{ steps.get-version.outputs.version }}
          body: |
            ## JaTerm RC ${{ steps.get-version.outputs.version }}
            
            This is a release candidate intended for testing. It may contain changes that are not yet in the stable channel.
            
            ### üì¶ Installation
            
            #### Windows
            - **Installer**: Download `JaTerm_*.msi` for standard installation
            - **Portable**: Download `JaTerm_*-setup.exe` for NSIS installer
            
            #### macOS
            - **Intel**: Download `JaTerm_*_macos-intel.dmg`
            - **Apple Silicon**: Download `JaTerm_*_macos-apple-silicon.dmg`
            
            #### Linux
            - **AppImage**: Download `JaTerm_*.AppImage` (portable, no installation)
            - **Debian/Ubuntu**: Download `JaTerm_*.deb`
            
            ### üìù Recent Changes
            ${{ steps.release-notes.outputs.changelog }}
            
            ---
            [View all commits](https://github.com/${{ github.repository }}/compare/${{ steps.get-version.outputs.last_tag }}...v${{ steps.get-version.outputs.version }})
          draft: false
          prerelease: true
          generate_release_notes: false

      - name: Create Stable Release (tag)
        id: create-release-tag
        if: startsWith(github.ref, 'refs/tags/v')
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ steps.get-version.outputs.version }}
          name: JaTerm v${{ steps.get-version.outputs.version }}
          body: |
            ## JaTerm v${{ steps.get-version.outputs.version }}
            
            ### üì¶ Installation
            
            #### Windows
            - **Installer**: Download `JaTerm_*.msi` for standard installation
            - **Portable**: Download `JaTerm_*-setup.exe` for NSIS installer
            
            #### macOS
            - **Intel**: Download `JaTerm_*_macos-intel.dmg`
            - **Apple Silicon**: Download `JaTerm_*_macos-apple-silicon.dmg`
            
            #### Linux
            - **AppImage**: Download `JaTerm_*.AppImage` (portable, no installation)
            - **Debian/Ubuntu**: Download `JaTerm_*.deb`
            
            ### üìù Recent Changes
            ${{ steps.release-notes.outputs.changelog }}
            
            ---
            [View all commits](https://github.com/${{ github.repository }}/compare/${{ steps.release-notes.outputs.last_tag }}...v${{ steps.get-version.outputs.version }})
          draft: false
          prerelease: false
          generate_release_notes: false

  build:
    needs: create-release
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            name: windows
            ext: .msi
            
          - os: macos-latest
            target: x86_64-apple-darwin
            name: macos-intel
            ext: .dmg
            
          - os: macos-latest
            target: aarch64-apple-darwin
            name: macos-apple-silicon
            ext: .dmg
            
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            name: linux
            ext: .AppImage

    runs-on: ${{ matrix.os }}
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8
          
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}
          
      - name: Install cargo-zigbuild (for cross-compilation)
        if: matrix.os == 'macos-latest' || matrix.os == 'ubuntu-latest'
        run: |
          cargo install cargo-zigbuild
          
      - name: Install Linux dependencies
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            librsvg2-dev \
            patchelf \
            libgtk-3-dev \
            libssl-dev
          # Try to install appindicator (use ayatana if available, fallback to older version)
          sudo apt-get install -y libayatana-appindicator3-dev || sudo apt-get install -y libappindicator3-dev
            
      # Certificates step removed - using ad-hoc signing instead
        
      - name: Update version (Unix)
        if: matrix.os != 'windows-latest'
        env:
          TAURI_UPDATER_PUBKEY: ${{ vars.TAURI_UPDATER_PUBKEY }}
        run: |
          VERSION="${{ needs.create-release.outputs.version }}"
          echo "Setting version to: $VERSION"
          
          # Update package.json
          sed -i.bak "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" package.json || true
          sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" package.json || true
          
          # Update src-tauri/Cargo.toml
          sed -i.bak "s/^version = .*/version = \"$VERSION\"/" src-tauri/Cargo.toml || true
          sed -i "s/^version = .*/version = \"$VERSION\"/" src-tauri/Cargo.toml || true
          
          # Update tauri.conf.json version
          sed -i.bak "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" src-tauri/tauri.conf.json || true
          sed -i "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" src-tauri/tauri.conf.json || true
          
          # Inject the public key if available
          if [ -n "$TAURI_UPDATER_PUBKEY" ]; then
            sed -i.bak "s/PUBKEY_PLACEHOLDER_REPLACE_IN_CI/$TAURI_UPDATER_PUBKEY/" src-tauri/tauri.conf.json || true
            sed -i "s/PUBKEY_PLACEHOLDER_REPLACE_IN_CI/$TAURI_UPDATER_PUBKEY/" src-tauri/tauri.conf.json || true
          fi
          
      - name: Update version (Windows)
        if: matrix.os == 'windows-latest'
        env:
          TAURI_UPDATER_PUBKEY: ${{ vars.TAURI_UPDATER_PUBKEY }}
        shell: pwsh
        run: |
          $VERSION = "${{ needs.create-release.outputs.version }}"
          Write-Host "Setting version to: $VERSION"
          
          # Update package.json
          $packageJson = Get-Content package.json -Raw | ConvertFrom-Json
          $packageJson.version = $VERSION
          $packageJson | ConvertTo-Json -Depth 10 | Set-Content -Path package.json -NoNewline
          
          # Update src-tauri/Cargo.toml
          $cargoContent = Get-Content src-tauri/Cargo.toml -Raw
          $cargoContent = $cargoContent -replace '(?m)^version = ".*"', "version = `"$VERSION`""
          Set-Content -Path src-tauri/Cargo.toml -Value $cargoContent -NoNewline
          
          # Update tauri.conf.json
          $configPath = "src-tauri/tauri.conf.json"
          $json = Get-Content $configPath -Raw
          $config = $json | ConvertFrom-Json
          $config.version = $VERSION
          
          # Update pubkey if available (top-level updater.pubkey)
          if ($env:TAURI_UPDATER_PUBKEY) {
            if (-not $config.updater) { $config | Add-Member -NotePropertyName updater -NotePropertyValue @{} }
            $config.updater.pubkey = $env:TAURI_UPDATER_PUBKEY
          }
          
          $newJson = $config | ConvertTo-Json -Depth 10
          Set-Content -Path $configPath -Value $newJson -NoNewline
          
      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            src-tauri
            src-helper
            
      - name: Install frontend dependencies
        run: pnpm install
        
      - name: Build helper binary (native)
        run: |
          cd src-helper
          cargo build --release --target ${{ matrix.target }}
          
      - name: Build helper binary for Linux (musl)
        if: matrix.os == 'macos-latest' || matrix.os == 'ubuntu-latest'
        run: |
          cd src-helper
          cargo zigbuild --release --target x86_64-unknown-linux-musl || true
        continue-on-error: true
        
      - name: Build Tauri app
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          pnpm tauri build --target ${{ matrix.target }}

      - name: Package helper (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path dist | Out-Null
          $helper = "src-helper/target/${{ matrix.target }}/release/jaterm-agent.exe"
          if (Test-Path $helper) { Copy-Item $helper -Destination "dist/jaterm-agent_windows_x64.exe" }
          
      - name: Fix macOS signatures and recreate DMG
        if: matrix.os == 'macos-latest'
        run: |
          # Fix the app bundle signature
          ./scripts/fix-macos-signature.sh --ci
          
          # Recreate the DMG with the properly signed app
          ./scripts/recreate-dmg.sh ${{ matrix.target }} ${{ needs.create-release.outputs.version }}
          
      - name: Prepare artifacts (Windows)
        if: matrix.os == 'windows-latest'
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
        shell: pwsh
        run: |
          # Windows creates MSI installer
          New-Item -ItemType Directory -Force -Path dist | Out-Null
          
          # Copy MSI installer
          $msiFiles = Get-ChildItem -Path "src-tauri\target\${{ matrix.target }}\release\bundle\msi\*.msi" -ErrorAction SilentlyContinue
          if ($msiFiles) {
            Copy-Item $msiFiles[0] -Destination "dist\JaTerm_${{ needs.create-release.outputs.version }}_x64.msi"
            
            # Copy MSI signature if available
            $sigFiles = Get-ChildItem -Path "src-tauri\target\${{ matrix.target }}\release\bundle\msi\*.msi.sig" -ErrorAction SilentlyContinue
            if ($sigFiles) {
              Copy-Item $sigFiles[0] -Destination "dist\JaTerm_${{ needs.create-release.outputs.version }}_x64.msi.sig"
            }
          }
          
          # Copy NSIS installer if available
          $exeFiles = Get-ChildItem -Path "src-tauri\target\${{ matrix.target }}\release\bundle\nsis\*.exe" -ErrorAction SilentlyContinue
          if ($exeFiles) {
            Copy-Item $exeFiles[0] -Destination "dist\JaTerm_${{ needs.create-release.outputs.version }}_x64-setup.exe"
          }
          
      - name: Prepare artifacts (macOS)
        if: matrix.os == 'macos-latest'
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
        run: |
          # macOS creates DMG and app.tar.gz for updater
          mkdir -p dist
          if [[ "${{ matrix.target }}" == "aarch64-apple-darwin" ]]; then
            # Copy DMG for manual installation
            cp src-tauri/target/${{ matrix.target }}/release/bundle/dmg/*.dmg dist/JaTerm_${{ needs.create-release.outputs.version }}_aarch64.dmg || true
            
            # Create app.tar.gz for auto-updater
            if [[ -d "src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app" ]]; then
              cd src-tauri/target/${{ matrix.target }}/release/bundle/macos/
              tar czf JaTerm.app.tar.gz JaTerm.app
              cd -
              cp src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app.tar.gz dist/JaTerm_${{ needs.create-release.outputs.version }}_aarch64.app.tar.gz
              
              # Generate signature for app.tar.gz if signing keys are available
              if [[ -n "$TAURI_SIGNING_PRIVATE_KEY" ]]; then
                echo "Generating signature for aarch64 app.tar.gz..."
                # Tauri should generate this automatically when built with signing keys
                if [[ -f "src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app.tar.gz.sig" ]]; then
                  cp src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app.tar.gz.sig dist/JaTerm_${{ needs.create-release.outputs.version }}_aarch64.app.tar.gz.sig
                fi
              fi
            fi
            
            # Copy helper (Apple Silicon)
            if [[ -f "src-helper/target/${{ matrix.target }}/release/jaterm-agent" ]]; then
              cp "src-helper/target/${{ matrix.target }}/release/jaterm-agent" "dist/jaterm-agent_macos_aarch64"
              chmod +x dist/jaterm-agent_macos_aarch64 || true
            fi
          else
            # Copy DMG for manual installation
            cp src-tauri/target/${{ matrix.target }}/release/bundle/dmg/*.dmg dist/JaTerm_${{ needs.create-release.outputs.version }}_x64.dmg || true
            
            # Create app.tar.gz for auto-updater
            if [[ -d "src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app" ]]; then
              cd src-tauri/target/${{ matrix.target }}/release/bundle/macos/
              tar czf JaTerm.app.tar.gz JaTerm.app
              cd -
              cp src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app.tar.gz dist/JaTerm_${{ needs.create-release.outputs.version }}_x64.app.tar.gz
              
              # Generate signature for app.tar.gz if signing keys are available
              if [[ -n "$TAURI_SIGNING_PRIVATE_KEY" ]]; then
                echo "Generating signature for x64 app.tar.gz..."
                # Tauri should generate this automatically when built with signing keys
                if [[ -f "src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app.tar.gz.sig" ]]; then
                  cp src-tauri/target/${{ matrix.target }}/release/bundle/macos/JaTerm.app.tar.gz.sig dist/JaTerm_${{ needs.create-release.outputs.version }}_x64.app.tar.gz.sig
                fi
              fi
            fi
            
            # Copy helper (Intel)
            if [[ -f "src-helper/target/${{ matrix.target }}/release/jaterm-agent" ]]; then
              cp "src-helper/target/${{ matrix.target }}/release/jaterm-agent" "dist/jaterm-agent_macos_x64"
              chmod +x dist/jaterm-agent_macos_x64 || true
            fi
          fi
          
      - name: Prepare artifacts (Linux)
        if: matrix.os == 'ubuntu-latest'
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
        run: |
          # Linux creates AppImage and deb
          mkdir -p dist
          
          # Copy AppImage and its signature for updater
          cp src-tauri/target/${{ matrix.target }}/release/bundle/appimage/*.AppImage dist/JaTerm_${{ needs.create-release.outputs.version }}_amd64.AppImage || true
          if [[ -f "src-tauri/target/${{ matrix.target }}/release/bundle/appimage/*.AppImage.sig" ]]; then
            cp src-tauri/target/${{ matrix.target }}/release/bundle/appimage/*.AppImage.sig dist/JaTerm_${{ needs.create-release.outputs.version }}_amd64.AppImage.sig || true
          fi
          
          # Copy deb package
          cp src-tauri/target/${{ matrix.target }}/release/bundle/deb/*.deb dist/JaTerm_${{ needs.create-release.outputs.version }}_amd64.deb || true
          
          # Make AppImage executable
          chmod +x dist/*.AppImage || true
          # Copy helper (gnu)
          if [[ -f "src-helper/target/${{ matrix.target }}/release/jaterm-agent" ]]; then
            cp "src-helper/target/${{ matrix.target }}/release/jaterm-agent" "dist/jaterm-agent_linux_x86_64"
            chmod +x dist/jaterm-agent_linux_x86_64 || true
          fi
          # Copy helper (musl) if built via zigbuild
          if [[ -f "src-helper/target/x86_64-unknown-linux-musl/release/jaterm-agent" ]]; then
            cp "src-helper/target/x86_64-unknown-linux-musl/release/jaterm-agent" "dist/jaterm-agent_linux_x86_64_musl"
            chmod +x dist/jaterm-agent_linux_x86_64_musl || true
          fi
          
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: jaterm-${{ matrix.name }}
          path: dist/
          
      - name: Upload Release Assets
        if: startsWith(github.ref, 'refs/tags/v') || startsWith(github.ref, 'refs/heads/release/')
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.create-release.outputs.version }}
          files: dist/*
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  generate-latest-json:
    needs: [create-release, build]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v') || startsWith(github.ref, 'refs/heads/release/')
    steps:
      - uses: actions/checkout@v4
      
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/
          
      - name: Prepare dist directory
        run: |
          mkdir -p dist
          # Copy all artifacts to dist, flattening the structure
          find artifacts -type f \( -name "*.msi" -o -name "*.AppImage" -o -name "*.dmg" -o -name "*.exe" -o -name "*.deb" -o -name "*.sig" -o -name "*.tar.gz" \) -exec cp {} dist/ \;
          ls -la dist/
          
      - name: Generate latest.json
        run: |
          VERSION="${{ needs.create-release.outputs.version }}"
          echo "Generating latest.json for version ${VERSION}"
          
          # Make script executable
          chmod +x scripts/generate-latest-json.sh
          
          # Generate latest.json
          ./scripts/generate-latest-json.sh "${VERSION}" "JaTerm ${VERSION} - Check the release page for details"
          
          # Verify it was created
          if [ -f dist/latest.json ]; then
            echo "latest.json generated successfully:"
            cat dist/latest.json
          else
            echo "Error: latest.json was not generated!"
            exit 1
          fi
          
      - name: Upload latest.json to Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.create-release.outputs.version }}
          files: dist/latest.json
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
